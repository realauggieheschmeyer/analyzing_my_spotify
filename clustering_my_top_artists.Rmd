---
title: "Clustering My Top Spotify Artists"
author: "Auggie Heschmeyer"
date: "5/24/2020"
output: html_document
theme: sandstone
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE)

library(spotifyr)
library(knitr)

Sys.setenv(SPOTIFY_CLIENT_ID = "a905fab479a848579b4a190f33e57aa6")
Sys.setenv(SPOTIFY_CLIENT_SECRET = "02c30b0b7def484b871779e6c0359704")

access_token <- get_spotify_access_token()
```

I recently discovered the [`spotifyr`](https://www.rcharlie.com/spotifyr/) package that allows you to access the Spotify API data within R. More importantly, it allows you the opportunity to download and analyze your own listening data. As a data nerd and an avid Spotify user, I thought it would make a fun exercise to see if there are any patterns within the music I listen to and if I can back up my self-described musical tastes ("alternative rock with a pop bent") with data.

In this post I'll take a look at my top artists and their genres tro see how similar they are. In my next post, I will look at my top songs or, as Spotify calls them, *tracks*.

### Setting Up the API

I won't go into the specifics about how to set up a developer account wtih Spotify because the package creators do a fine job explaining how to do so on the [`spotifyr` website](https://www.rcharlie.com/spotifyr/). Once you have your credentials, however, getting access is as simple as three lines of code.

```{r eval=FALSE}
library(spotifyr)

Sys.setenv(SPOTIFY_CLIENT_ID = 'xxxxxxxxxxxxxxxxxxxxx')
Sys.setenv(SPOTIFY_CLIENT_SECRET = 'xxxxxxxxxxxxxxxxxxxxx')

access_token <- get_spotify_access_token()
```

### Getting My Top Artist Data

The `spotifyr` package contains a plethora of ways to interact with Spotify's API, but to access my top artists, we can use the appopriately named `get_my_top_artists_or_tracks()` function. This function has a number of arguments, but the three we are most concerned with for this analysis are `type`, `limit` and `time_range`. `type` and `limit` are straightforward and allow us to define whether we want artist or track data along with how many records we want to return, respectively. We're going to use `"artist"` and `50` as our values ofr this analysis.

The `time_range` argument is a little more involved. Rather than being able to specify an exact date range, `time_range` takes three possible arguments as strigns: `"short_term"`, `"median_term"` or `"long_term"`. The [Spotify for Developers reference guide](https://developer.spotify.com/documentation/web-api/reference/personalization/get-users-top-artists-and-tracks/) defines these as approximately "the last 4 weeks," "the last 6 months" and "several years," respectively. The argument defaults to `"median_term"` and that's what we'll stick with today as I'm most interested in what I've been listening to this year.

Finally, since I am a fan of working within the `tidyverse`, we're going to save the output of `get_my_top_artists_or_tracks()` as a tibble.

```{r}
library(tidyverse)

my_top_artists_tbl <- get_my_top_artists_or_tracks(
  type = "artists",
  limit = 50,
  time_range = "medium_term"
) %>% 
  as_tibble()
```

Let's take a quick `glimpse()` at our data.

```{r}
my_top_artists_tbl %>% 
  glimpse()
```

As you can see, we have the artist `name`, some info on their `genres` and `popularity` as well as some metadata including `uris` and `urls`. Let's take a look at who my top 10 artists have been.

```{r}
my_top_artists_tbl %>% 
  mutate(my_ranking = row_number()) %>% 
  select(my_ranking, name) %>% 
  slice(1:10) %>% 
  kable()
```

For those of you who don't know me all that well, this should give you a great sense of the type of music I enjoy. If I had to list my ten favorite artists right now, while the order wouldn't be the same, all but one of these artists would make the list (sorry, Asking Alexandria ¯\\_(ツ)_/¯). Additionally, it makes sense to me that a lot of these artists made the list as they just had new albums come out in the last few months ([The 1975](https://open.spotify.com/album/0o5xjCboti8vXhdoUG9LYi), [The Weeknd](https://open.spotify.com/album/1wSmi4DMuPu5fG7xtyspT2), [Asking Alexandria](https://open.spotify.com/album/5VKKXDvYuJmRc2UQHCwNQK) and [Palaye Royale](https://open.spotify.com/album/3J4E2dsY59qa56c3zm9ThZ)) and I'm a sucker for a new bop.

Spotify provided us with a popularity score for each of these artists, so let's see how my rankings stack up against the rest of Spotify listeners. We'll use the `ggdark` package here to make our plot look a little more on-brand for Spotify.

```{r}
library(ggdark)

my_top_artists_tbl %>% 
  mutate(
    my_ranking = row_number(),
    name = name %>% as_factor() %>% fct_reorder(popularity)
  ) %>% 
  slice(1:10) %>% 
  ggplot(aes(x = popularity, y = name)) +
  geom_col(fill = "#1DB954") +
  dark_theme_minimal() +
  labs(
    title = "My Top 10 Artists Over the Last Six Months",
    subtitle = "Ordered by Artist's Spotify Popularity",
    x = "Popularity",
    y = "Artist"
  )
```

One thing to take note of is that there already appears to be some clustering going on within this group in terms of each artists' popularity. The Weeknd appears to be far more popular than any other artist on my list due to him being the only pop/Top 40 musician. Twenty One Pilots, The 1975 and Bastille, however, all have similar popularity levels and are all more popular than the next set of artists. Finally, Palaye Royale and The Band CAMINO are the least popular of all due to the fact that they're just recently starting to gain popularity. This indicates to me that popularity is a variable worth including when it comes time to start clustering these artists.

### Exploring Genres

If you recall from above, the `my_top_artists_tbl` has a variable called `genre`. This is stored as a nested list, so to access each list of genres, we'll have to do a little more manipulation.

```{r}
artists_genre_long_tbl <- my_top_artists_tbl %>% 
  select(name, popularity, followers.total, genres) %>% 
  unnest(genres)

artists_genre_long_tbl %>% 
  head() %>% 
  kable()
```

Now we have one row per genre per artist. Let's use the `tidytext` package to do some basic text mining and see which genres are most common among my top artists.

```{r}
library(tidytext)

artists_genre_long_tbl %>% 
  unnest_tokens(word, genres) %>% 
  count(word, sort = TRUE) %>% 
  slice(1:10) %>% 
  kable()
```

There are some expected results in this list (pop, rock, alternative), but it appears some subgenre modifiers have made their way onto the list as well (modern, post). We could expand this list to get a more nuaced picture of my listening, but since the counts are already getting small, I hesitate to add anything more. 

Let's turn each of these top genres into a binary variable indicating whether an artist fits that profile. Additionally, we'll normalize `popularity` and `followers.total` so that they have a mean of 0 and standard deviation of 1. This will ensure that they don't have undue weighting in the clustering algorthim. We'll make use of the `recipes` and `textrecipes` packages. 

```{r}
library(recipes)
library(textrecipes)

artists_genre_processed_tbl <- recipe(name ~ ., data = artists_genre_long_tbl) %>% 
  step_tokenize(genres) %>% 
  step_tokenfilter(genres, max_tokens = 10) %>% 
  step_tf(genres, weight_scheme = "binary") %>% 
  step_normalize(popularity, followers.total) %>%
  prep() %>% 
  juice() %>% 
  group_by(name, popularity, followers.total) %>% 
  summarize_all(max) %>% 
  ungroup() %>% 
  set_names(names(.) %>% str_replace_all("\\.", "_"))
```

Let's see how it looks.

```{r}
artists_genre_processed_tbl %>% 
  glimpse()
```

It looks like pop is a popular genre/subgenre.

### K-Means Clustering

Now that we have our data in a cluster-friendly format, let's define a functions that's going to allow us to utilize a k-means clustering algorithm in a tidy way.

```{r}
kmeans_mapper <- function(data, centers = 3) {
  
  data %>%
    kmeans(centers = centers, nstart = 100)
  
}
```

What this function is going to allow us to do is to test a range of clusters (1-15) and store the results of the clustering algorithm in a tibble format. Additionally, we're going to use the `glance()` function from the `broom` package to extract relevant metrics from the algorithm.

```{r}
library(broom)

kmeans_artists_mapped_tbl <- tibble(centers = 1:15) %>% 
  mutate(k_means = centers %>% map(kmeans_mapper, data = artists_genre_processed_tbl %>% select(-name)),
         glance = k_means %>% map(glance))
```

I would print the `kmeans_artists_mapped_tbl`, but it's a bunch of nested data and isn't much to look at. Instead, we'll extract the necessary information from each model to make a skree plot and see if there is an ideal number of clusters.

```{r}
kmeans_artists_mapped_tbl %>%
  unnest(glance) %>%
  select(centers, tot.withinss) %>%
  ggplot(aes(x = centers, y = tot.withinss)) +
  geom_point(color = "#1DB954", size = 4) +
  geom_line(color = "#1DB954") +
  dark_theme_minimal() +
  labs(title = "Skree plot")
```

It doesn't look like there is a discernable "elbow" to this plot, so we'll arbitrarily pick three. Okay, maybe it's not totally arbitrary; I just don't think my taste in music is that varied.

### Dimensionality Reduction

To be able to show the results of our clustering exercise, we'll use a dimensionality reduction process to convert all of our popularity and genre data into two dimensions (for x and y axes).